[
    {
        "index": 783,
        "message": "@IvanSanchez The active marker: zIndexOffset = 5, zIndex = 239\nInactive marker: zIndexOffset = 10, zIndex = 567\nDo you want me to try artificially update the zIndexOffset of the active marker on click and check whether it will reappear on top of inactive one? I really doubt it'll happen.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 786,
        "message": "> Actually it did.. I've used marker.setZIndexOffset(100) on the clicked active marker (A) that was below and it appeared on top of inactive one (B) but then the click on B made it on top and clicking A again has left it behind. This means that I'll need to recalculate all markers zIndexOffsets on the map to make it work as I need which is too much.\nNo. It means that you have to reset the `zIndexOffset` of a marker whenever it changes state from inactive to active, or from inactive to active.\n> This way we'll reach enormous values for zIndex which also seems not good...\nA `zIndex` is an integer which can go up to the millions, and we *never* had any issue with high values. We do know that some browsers have a limit on integer CSS properties of 2^23 (see https://github.com/Leaflet/Leaflet/commit/c5172f3088b820325e726f57f0b09b16b1ec498d, https://github.com/Leaflet/Leaflet/commit/17c180e1eff97932c3450447d5d17fda199f7c2c), but `zIndex`es have never been a big problem, because Leaflet recalculates them once in a while on every `viewreset`, so the values for both the CSS transforms and the `zIndex`es are within a manageable range.\nIn my experience, it's better to learn about the [stacking context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/Stacking_without_z-index) than to be afraid of misusing `z-index`.\n> That's the point that in case I could have managed the actual zIndex of markers on the map it would solve everything [...]\nNo you wouldn't, because if you're not resetting the `zIndex`es of the markers which transition from active to inactive, you would end up with the same problem.\nI mean, if you want to *really* try if your logic would work without Leaflet's management of `zIndex`/`zIndexOffset`, you can manually disable it with something like\n```js\nL.Marker.prototype._updateZIndex = function(offset) {\n// this._icon.style.zIndex = this._zIndex + offset;\n}\n```\nSo far, you've been subtly suggesting that Leaflet is the culprit and that your logic is infallible. [Programmers like myself don't react well to this kind of bug reporting](https://www.chiark.greenend.org.uk/~sgtatham/bugs.html#symptoms). I bet you a beer that the problem is in the logic in your side, and that it won't matter if you manage raw `zIndex`es or `zIndexOffset`s.\nIf you can *isolate* a case where Leaflet fails to raise a marker's `zIndex` when raising its `zIndexOffset`, of fails to lower it, please do share a playground or similar.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 800,
        "message": "There's nothing but the DOM here, really.\nThere's no need to explain anything else, if 600 is the containing element limit set statically in the library it doesn't matter what you set them at and that is based on how the layers are applied.\n@Falke-Design",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 806,
        "message": "Anything you would like to do is totally fine by me, as the license for the software is permissive. I just do not want to merge anything into mainline that concerns type hinting.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 812,
        "message": "> No, type hints are, in my opinion, an abomination that has no business being part of the Python language :)\nAs a maintainer of typeshed, a big repository that is all about typing in Python, I think this is a perfectly valid opinion! I felt the same when I first learned about typing in Python. It shouldn't be something that library authors have to do, and it's optional by design.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 820,
        "message": "Any news when this is planned to be implemented in ansible?\nWe have lots of passwords as vaulted variables, hence updating\\viewing them is troublesome.\nI did some script (based on solution, from alikins last post) to at least parse such yml and decrypt every variable to stdout\\file to see a decrypted file at once, but this is just a script that is not a complete solution (and it is decrypting only).\nUPD: I ended up going thru ansible code to understand how it works with encrypted variables and wrote some tiny script that I can use in my automation jobs with Jenkins. I hope it would be useful for anyone who is waiting for this issue to be fixed.\nhttps://github.com/andrunah/ansible-vault-variable-updater\nIt would be nice to have this functionality in ansible out of the box.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 829,
        "message": "Also related, let rekey work on all encrypted variables in a file. There doesn't seem to be a good way to rekey all the encrypted variables, which makes encrypted variables super cumbersome now that we have to rekey (will end up having script this). Even if it just spits it back out to stdout that'd be a huge help instead of modifying the variables in the file directly.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 837,
        "message": "maybe a bit unrelated but I like how [sops](https://github.com/mozilla/sops) does it.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 838,
        "message": "Running into this issue again and it sucks. Please guys, this issue has been open for almost 2 years now and for people who really use ansible-vault, this is a major pain the butt.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 846,
        "message": "A few expansions to @whirlwin's clever workaround:\nInstead of a specific var, you can have ansible dump all vars (encrypted and plain) by specifying `-a var=\"vars\"`. There will be some noise in the result with a few stock vars, but it's a nice way to see everything at once.\nYou can also specify multiple source files by passing multiple `-e \"@...\"` args.\nAlso, I haven't tested this personally but you can apparently avoid the implicit `localhost` warnings by setting `ANSIBLE_LOCALHOST_WARNING=false` on Ansible 2.6+.\nAll together:\n```\nANSIBLE_LOCALHOST_WARNING=false ansible localhost -m debug -a var=\"vars\" \\\n-e \"@file1.yml\" -e \"@path/to/file2.yml\" -e \"@path/to/file3.yml\"\n```\nplus `--ask-vault-pass` if needed.\nObviously a built-in solution would be much better, but this makes mixed plain/encrypted var files somewhat workable.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 849,
        "message": "+1 for this feature",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 852,
        "message": "Continuing discussion from https://github.com/pallets/meta/issues/10#issuecomment-209980352\nThe naming is inconsistent:\n- Github repo is `jinja`\n- Pypi package name is `jinja2`\n- Pallets project calls it \"Jinja\": https://www.palletsprojects.com/p/jinja/\n- RTD namespace is jinja2.readthedocs.io\n- Pocoo docs (currently the official ones) are \"Jinja\": http://jinja.pocoo.org/docs/2.9/\n- file extensions are sometimes `.jinja`, `.j2`, `.jinja2`... Ansible project currently uses `.j2`\nWe should pick either \"Jinja\" or \"Jinja2\" and use it everywhere for consistency. I am open to either, \"Jinja\" is simpler and shorter, but \"Jinja2\" has a more distinctive ring to it and less likely to get confused with any other projects.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 859,
        "message": "In a way the last major release of Jinja2 was a massive change in the engine. Not even sure if there is more stuff we need to break :D",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 863,
        "message": "@davidism this shouldn't happen in a point release. This would break pickle and a bunch of other things.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 876,
        "message": "> My main concern with DI is it often leads to the use of mocking in tests. Mocks have a strong tendency to deviate from the documented pre- and post-conditions of the original interfaces\nI am not sure if completely I understand your point.\nIf each class has a single responsibility (SR), then DI should not add any ambiguity - for each use case you set dependencies to imitate boundary conditions, but you **only** exercise and validate functionality of the class under test.\nAny changes to dependencies should not have any profound effect because the class is built against a contract and not a particular implementation. Certainly a degree of coupling is possible, but it typically it will be lose coupling.\nAlso a SR class (usually) define a limited number of methods (accessible via an interface). As a result you test the public surface. Generally there is a limited need to test internal or private methods (due to their absence).\nAnother benefit of smaller classes with SR - you know exactly what each class depends on. For example right now `GitModule` spans across 3,400+ lines of code carrying hundreds of methods. And we inject this monstrosity to classes which may need to access only one method from the lot...\nIf a class has multiple responsibilities and/or initialises its own concrete dependencies then it is virtually impossible to perform unit testing - instead you will be writing integration tests. Any changes to dependencies with high degree of probability will necessitate changes to the class, because there is a tight coupling to concrete implementations.\nWrt: code coverage - whilst it is a very useful metric, it shouldn't be viewed as an absolute. 100% CC can be very misleading.\nPersonally when I write tests I usually strive for 100% coverage taking in consideration various edge cases. I use NCrunch, it helps me to visualise what cases I may have missed.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 885,
        "message": "I'm not sure what you perceive as a problem in attached links, I'm sorry.\nThe classes under tests are stateless - they do not have any settable fields or properties (outside the container) nor they access any objects besides those passed via the container. The external dependencies are interface-based, and as such they are stateless too. So there are no side effects and there are external context mutations - so I can assert the correctness of my implementation.\nThe unit tests exercise my class implementations and check the flow of execution by checking how far each use case progresses and what methods within the method under test were called. There is no magic here :)\nOf course there is an arrangement phase, you can't not have it. But the arrangement only sets a possible return from the underlying dependency (boundary conditions). My duty as a class developer write unit tests to account for these boundary conditions and facilitate stable predictable response.\n**EDIT:**\nJust realised some classes may be accessing `AppSettings` which arguably belongs to the external context, but for the most part we can presume AppSettings to be immutable. They should be abstracted too.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    },
    {
        "index": 888,
        "message": "> The following test tests implementation.\nYes, because as a class developer I need to ensure the order of execution to ensure the expected behavior.\nAs a class consumer you don't care about it - you expect by calling a method something happens and that something happens in expected predictable manner.\nAny changes to my class behaviors should only really affect my class. And for a consumer of the class the changes should be transparent. For example, as a consumer by calling `_repo.GetRecord(id: 1)` I expect to get record with id=1 - whether the record is in a database, xml file or a remote service I don't care. If repo implementaion is migrated from a database to a remote service or an xml file - it is an implementation detail for the repository implementation and I shouldn't change my implementation.\nOn the other hand, as a repository developer in its implementation I would probably want to make sure that the database connection is established before I attempt to interact with the database. Naturally in the repository tests I would expect to see something like `_db.Received(1).Open()`.\n. . .\n> Apparently we have a different understanding of \"stateless\". The config file holds a state. Invoking its methods changes this state.\nIndeed we are :smile: As a consumer I interact with an interface - I don't know nor expected to care about the implementation detail of the instance given to me at runtime. By virtue of this the dependency is treated as stateless.\n. . .\nBtw `GitRemoteController` isn't a stateless implementation, it has a bunch of side effects and it maintains the state in `Remotes` list. So it is probably not the best example to use.\nTo sum it up:\nWe probably won't be able to make everything stateless, not from the get go anyway:\n- the codebase isn't ready for it yet, and\n- UI layer is typically stateful.\nIf we go with interface-based implementations it is much easier to write smaller SR implementations which can be easily tested. It is much easier to make implementations stateless too. You get benefits of declarative composition - it is easy to see objects connections and dependencies. As well as DI and substitutions - i.e. you could have Windows- and Linux-specific implementations without random `if running on Windows do this else do that`.",
        "strategy": "role_based_few_shot",
        "model": "gpt-4o-mini",
        "error": "cannot access local variable 'class_name' where it is not associated with a value"
    }
]